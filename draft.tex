\documentclass{llncs}
% \documentclass[10pt,conference,letterpaper,twocolumn]{IEEEtran}

\usepackage[usenames,dvipsnames]{color}

\usepackage{latexsym}
\usepackage{amsxtra} 
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{pslatex}
\usepackage{epsfig}
\usepackage{wrapfig}
\usepackage{paralist}
% \usepackage{stmaryrd}
\usepackage{txfonts}
\usepackage{framed}
\usepackage{makecell}
\usepackage{url}
\usepackage{tikz}
\usetikzlibrary{automata,positioning, calc}
\usepackage[inline,shortlabels]{enumitem}

\usepackage{proof}

\usepackage{algorithm}
\usepackage{algorithmicx}
\usepackage[noend]{algpseudocode}

\usepackage[draft]{commenting}

\pagestyle{plain}

\include{commands-lncs}

\declareauthor{ri}{Radu}{blue}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\title{First Order Alternation}

\author{Radu Iosif and Xiao Xu}
\institute{
  CNRS, Verimag, Universit\'e de Grenoble Alpes \\
  Email: \{Radu.Iosif,Xiao.Xu\}@univ-grenoble-alpes.fr
}

\maketitle

\begin{abstract}
\end{abstract}

\section{Preliminaries}

For two integers $0 \leq i \leq j$, we denote by $[i,j]$ the set
$\set{i,i+1,\ldots,j}$ and by $[i]$ the set $[1,i]$, where $[0]$ is
the empty set. To simplify the presentation, we consider two sorts
$\Data$ and $\Bool$, where $\Data$ ranges over an infinite domain and
$\Bool$ has the usual interpretation. The $\Data$ sort is equipped
with a finite set of function symbols $f : \Data^{\#(f)} \rightarrow
\Data$, where $\#(f)\geq0$ denotes the number of arguments (arity) of
$f$. When $\#(f)=0$, we say that $f$ is a constant, and denote by
$\top$ and $\bot$ the only constants of sort $\Bool$, representing the
true and false values, respectively.  For conciseness, in the
following we blur the distinction between the sort and function
symbols and their interpretations. A \emph{predicate} is a function
symbol $p : \Data^{\#(p)} \rightarrow \Bool$, denoting a relation of
arity $\#(p)$.

Let $\vars = \set{x,y,z,\ldots}$ be an infinite countable set of
variables, ranging over the interpretation of the $\Data$ sort. Terms
are either constants of sort $\Data$, variables or function
applications. The set of \emph{positive} formulae is defined by the
syntax below: 
\[\phi := t \teq s \mid t \not\teq s \mid p(t_1,\ldots,t_{\#(p)}) 
\mid \phi_1 \wedge \phi_2 \mid \phi_1 \vee \phi_2 \mid \exists x ~.~
\phi_1 \mid \forall x ~.~ \phi_1\] where $t,s,t_1,\ldots,t_{\#(p)}$
denote terms. We denote by $\fv{}{\phi}$ the set of free variables in
$\phi$. A \emph{sentence} is a formula $\phi$ in which each variable
occurs under the scope of a quantifier, i.e. $\fv{}{\phi} =
\emptyset$. The size $\len{\phi}$ is the number of symbols occuring in
$\phi$. 

%% For a variable $x \in \fv{}{\phi}$ and a term $t$, let $\phi[t/x]$ be
%% the result of replacing each occurrence of $x$ by $t$. For indexed
%% sets of terms $T=\set{t_1,\ldots,t_n}$ and variables
%% $X=\set{x_1,\ldots,x_n}$, we write $\phi[T/X]$ for the formula
%% obtained by simultaneously replacing each occurrence of $x_i$ with
%% $t_i$ in $\phi$, for all $i\in[n]$.

An \emph{interpretation} $\I$ maps each predicate $p$ into a set $p^\I
\subseteq \Data^{\#(p)}$, if $\#(p)>0$, or into an element of $\Data$
if $\#(p)=0$. A \emph{valuation} $\nu$ maps each variable $x$ into an
element of $\Data$. Given a term $t$, we denote by $t^\nu$ the value
obtained by replacing each variable $x$ by the value $\nu(x)$ and
evaluating each function application. For a formula $\phi$, we define
the forcing relation $\I,\nu \models \phi$ recursively on the
structure of $\phi$, as follows:
\[
\begin{array}{rcl}
\I,\nu \models t \teq s & \iff & t^\nu=s^\nu \\
\I,\nu \models t \not\teq s & \iff & t^\nu \neq s^\nu \\
\I,\nu \models \phi_1 \wedge \phi_2 & \iff & \I,\nu \models \phi_i \text{, for all } i=1,2 \\ 
\I,\nu \models \phi_1 \vee \phi_2 & \iff & \I,\nu \models \phi_i \text{, for some } i=1,2 \\
\I,\nu \models \forall x ~.~ \phi_1 & \iff & \I,\nu[x\leftarrow d] \models \phi_1 \text{, for all } d \in \Data \\
\I,\nu \models \exists x ~.~ \phi_1 & \iff & \I,\nu[x\leftarrow d] \models \phi_1 \text{, for some } d \in \Data \\
\I,\nu \models p(t_1,\ldots,t_{\#(p)}) & \iff & \tuple{t_1^\nu,\ldots,t_{\#(p)}^\nu} \in p^\I 
\end{array}
\]
For a formula $\phi$, we define $\sem{\phi}_\nu \isdef \set{\I \mid
  \I,\nu \models \phi}$, where $\nu(x)$ is defined for each $x \in
\fv{}{\phi}$, and drop the subscript for sentences. An element of
$\sem{\phi}$ is called a \emph{model} of $\phi$. A formula is
satisfiable if $\sem{\phi}\neq\emptyset$. 

\section{First Order Alternating Automata}

Let $\Sigma$ be a finite alphabet $\Sigma$ of \emph{input
  events}. Given a finite set of variables $X$, we denote by $X
\mapsto \Data^\I$ the set of valuations of the variables $X$ and
$\Sigma[X] = \Sigma \times (X \mapsto \Data)$ be the possibly infinite
set of \emph{data symbols}. A \emph{data word} (word) is a finite
sequence $(a_1,\nu_1)(a_2,\nu_2) \ldots (a_n,\nu_n)$ of data symbols,
where $a_1,\ldots,a_n \in \Sigma$ and $\nu_1,\ldots,\nu_n : X
\rightarrow \Data$ are valuations. We denote by $\varepsilon$ the
empty sequence, by $\Sigma^*$ the set of finite sequences of input
events and by $\Sigma[X]^*$ the set of data words over the variables
$X$.

A \emph{first-order alternating automaton} (automaton) is a tuple $\A
= \tuple{\Sigma,X,Q,\iota,F,\Delta}$, where $\Sigma$ is the finite
event alphabet, $X$ is a finite set of variables, $Q$ is a finite set
of predicates, $\iota$ is a satisfiable sentence, $F \subseteq Q$ is a
set of \emph{final predicates} and $\Delta$ is a set of
\emph{transition rules} of the form \(q(y_1,\ldots,y_{\#(q)})
\arrow{a(X)}{} \psi\), where $q \in Q$ is a predicate, $a \in \Sigma$
is an input event, $X \cap \set{y_1,\ldots,y_{\#(q)}} = \emptyset$,
$\psi$ is a positive formula such that $\fv{}{\phi} \subseteq X \cup
\set{y_1,\ldots,y_{\#(q)}}$ and each predicate that occurs in $\psi$
belongs also to $Q$. The \emph{size} of $\A$ is defined as $\len{\A} =
\len{\iota} + \sum_{q(\vec{y}) \arrow{a(X)}{} \psi \in \Delta}
\len{\psi}$.

Intuitively, $a$ is the input event and $X$ are the input data values
that trigger the transition, whereas $q$ and $y_1,\ldots,y_{\#(q)}$
are the current control state and data values pertaining to that
state, respectively. Without loss of generality, we consider, for each
predicate $q \in Q$ and each input event $a \in \Sigma$, at most one
such rule (two or more rules can be joined using disjunction). 

Given a predicate $q \in Q$ and a tuple of data values
$d_1,\ldots,d_{\#(q)}$, the tuple $q(d_1,\ldots,d_{\#(q)})$ is called
a \emph{configuration}\footnote{Note that a configuration is not a
  logical term since data values cannot be written in logic.}.
Because we consider an alternating model of computation, an automaton
can find itself, at the same time, in more than one
configuration. Typically, in the classical literature on alternating
machines, this set is finite. In our case, due to the presence of
first-order quantifiers ranging over an infinite data domain, we
consider that an automaton can be also in an infinite set of
configurations, all at once.

To formalize the execution semantics of automata, we relate sets of
configurations to models of first-order sentences, as follows. Given a
formula $\phi$ and a valuation of its free variables $\nu$, each
interpretation $\I \in \sem{\phi}_\nu$ corresponds to a set of
configurations $\cube{\I} \isdef \set{q(d_1,\ldots,d_{\#(q)}) \mid
  \tuple{d_1,\ldots,d_{\#(q)}} \in q^\I}$, called a \emph{cube}. For a
set $\mathcal{M}$ of interpretations, we define $\cube{\mathcal{M}}
\isdef \set{\cube{\I} \mid \I \in \mathcal{M}}$.

Given a word $w=(a_1,\nu_1)(a_2,\nu_2) \ldots (a_n,\nu_n) \in
\Sigma[X]^*$, an \emph{execution} of
$\A=\tuple{\Sigma,X,Q,\iota,F,\Delta}$ over $w$ is a (possibly
infinite) forest $\F_w = \set{T_1,T_2,\ldots}$, where each $T_i$ is
defined below:
\begin{compactitem}
\item $T_i$ is rooted in a configuration from some cube $C \in
  \cube{\sem{\iota}}$ --- since $\iota$ is satisfiable, such cube
  always exists,
%
\item all paths from the root to a leaf of $T_i$ have length $n$,
%
\item if $q(d_1,\ldots,d_{\#(q)})$ is a node on level $j \in [0,n-1]$
  in $T_i$, then its children form a cube $C \in
  \cube{\sem{\psi}_\eta}$, where \(q(y_1,\ldots,y_{\#(q)})
  \arrow{a_{j+1}(X)}{} \psi \in \Delta\) is a transition rule and
  $\eta$ is a valuation that assigns each variable $y_k$ the value
  $d_k$, for $k \in [1,\#(q)]$ and each variable $x \in X$ the value
  $\nu_{j+1}(x)$ --- because $\fv{}{\psi} \subseteq
  \set{y_1,\ldots,y_{\#(q)}} \cup X$, the values assigned by $\eta$ to
  variables outside $\set{y_1,\ldots,y_{\#(q)}} \cup X$ are not
  important for $\cube{\sem{\psi}_\eta}$.
\end{compactitem}
A forest $\F_w$ is said to be \emph{accepting} if and only if the
frontier of each tree $T \in \F_w$ is labeled with configurations
$q(d_1,\ldots,d_{\#(q)})$ such that $q \in F$ is a final predicate. In
this case, we say that $\A$ accepts $w$ and denote by $\lang{\A}$ the
set of words accepted by $\A$. In this paper, we answer the following
questions: \begin{compactenum}
\item \emph{closure}: given automata $\A_i =
  \tuple{\Sigma,X,Q_i,\iota_i,F_i,\Delta_i}$, for $i=1,2$, do there
  exist automata $\A_\cap$, $\A_\cup$ and $\overline{\A}_1$ such that
  $L(\A_\cap) = L(\A_1) \cap L(\A_2)$, $L(\A_\cup) = L(\A_1) \cup
  L(\A_2)$ and $L(\overline{\A}_1) = \Sigma[X]^* \setminus L(\A_1)$ ?
%
\item \emph{emptiness}: given an automaton $\A$, is $L(\A) =
  \emptyset$?
\end{compactenum}

\subsection{Symbolic Execution}

In several of the upcoming developments it is more convenient to work
with a symbolic execution semantics, that describes a set of execution
forests by a sequence of formulae obtained one from another using
rewriting rules. Let $\A = \tuple{\Sigma,X,Q,\iota,F,\Delta}$ be an
automaton and $\stamp{X}{i} = \set{\stamp{x}{i} \mid x \in X}$ be a
set of \emph{time-stamped} variables. For a formula $\psi$ and $i \in
\nat$, we define $\stamp{\psi}{i} = \psi[X/\stamp{X}{i}]$, i.e.\ the
formula in which each variable $x \in X$, denoting an input data
element, is replaced by $\stamp{x}{i}$. Further, given a formula
$\phi$, let $\Accept{F}{\phi}$ be the formula obtained from $\phi$ by
replacing each predicate atom $q(z_1,\ldots,z_{\#(q)})$ by $\top$ if
$q \in F$, and by $\bot$, otherwise.

For a sequence of input events $a_1 \ldots a_n \in \Sigma^*$, we
consider the sequence of formulae \(\phi_0 \stackrel{a_1}{\Rightarrow}
\phi_1 \stackrel{a_2}{\Rightarrow} \ldots \stackrel{a_n}{\Rightarrow}
\phi_n\), where $\phi_0 = \iota$ and $\phi_{i+1}$ is obtained from
$\phi_i$ by replacing each predicate atom $q(t_1,\ldots,t_{\#(q)})$
from $\phi_i$ by the formula $\stamp{\psi}{i+1}[t_1, \ldots,
  t_{\#(q)}/y_1,\ldots,y_{\#(q)}]$, where $q(y_1,\ldots,y_{\#(q)})
\arrow{a_i(X)}{} \psi \in \Delta$ is the only transition rule that
applies, or by $\bot$, if no transition rule applies. The following
lemma formalizes the relation between symbolic execution and the
low-level configuration-based semantics of automata:

\begin{lemma}\label{lemma:symbolic-execution}
  A word $(a_1,\nu_1) \ldots (a_n,\nu_n)$ is accepted by $\A =
  \tuple{\Sigma,X,Q,\iota,F,\Delta}$ if and only if $\I,\nu \models
  \Accept{F}{\phi_n}$ for each interpretation $\I$, where the
  valuation $\nu : \bigcup_{i=1}^n \stamp{X}{i} \rightarrow \Data$ is
  defined as $\nu(\stamp{x}{i}) = \nu_i(x)$, for each $x \in X$ and $i
  \in [n]$.
\end{lemma}
\proof{ ``$\Rightarrow$'' Assume that $w = (a_1,\nu_1) \ldots
  (a_n,\nu_n)$ is accepted by $\A$ and let $\F_w$ be an execution
  forest of $\A$ over $w$. First, it is easy to check that $\phi_i$ is
  a positive formula, for each $i \in [n]$. Next, we define the
  interpretation: \[\I^w_n(q) = \set{\tuple{d_1,\ldots,d_{\#(q)}} \mid
    q(d_1,\ldots,d_{\#(q)}) \text{ occurs on the $n$-th level of }
    F_w}\] and prove $\I^w_n,\nu \models \phi_n$, by induction on
  $n\geq0$. For $n=0$, we have $\cube{\I^w_0} \in
  \cube{\sem{\iota}}$ and $\I^w_0 \models \iota$ follows, by
  definition. For the induction step, assume that $\I^w_{n-1},\mu
  \models \phi_{n-1}$, where $\mu(\stamp{x}{i}) = \nu_i(x)$, for each
  $x \in X$ and $i \in [n-1]$. 


  \noindent''$\Leftarrow$'' 
\qed}

\subsection{Closure Properties}

Given a positive formula $\phi$, we define the \emph{dual} formula
$\dual{\phi}$ recursively on the structure of $\phi$ as follows: 
\[\begin{array}{rclcrclcrcl}
\dual{(\phi_1 \vee \phi_2)} & = & \dual{\phi_1} \wedge \dual{\phi_2} && 
\dual{(\phi_1 \wedge \phi_2)} & = & \dual{\phi_1} \wedge \dual{\phi_2} &&
\dual{(t \teq s)} & = & \neg(t \teq s) \\
\dual{(\exists x ~.~ \phi_1)} & = & \forall x ~.~ \dual{\phi_1} && 
\dual{(\forall x ~.~ \phi_1)} & = & \exists x ~.~ \dual{\phi_1} && 
\dual{(\neg(t \teq s))} & = & t \teq s \\
\dual{(q(x_1,\ldots,x_{\#(q)}))} & = & q(x_1,\ldots,x_{\#(q)})
\end{array}\]
Observe that, because predicate atoms do not occur negated in $\phi$,
there is no need to define dualization for formulae of the form $\neg
q(x_1,\ldots,x_{\#(q)})$. The dualization operation has the following
property:
\begin{lemma}\label{lemma:dual}
  Given a formula $\phi$ and an automaton
  $\A=\tuple{\Sigma,X,Q,\iota,F,\Delta}$, we have the equivalence
  $\Accept{F}{\phi} \equiv \neg(\dual{\Accept{Q\setminus F}{\phi}})$. 
\end{lemma}
\proof{ By straightforward induction on the structure of $\phi$. \qed}

The following theorem shows that first-order alternating data automata
are closed under all boolean operations: 

\begin{theorem}\label{thm:closure}
  Given automata $\A_i = \tuple{\Sigma,X,Q_i,\iota_i,F_i,\Delta_i}$,
  for $i=1,2$, such that $Q_1 \cap Q_2 = \emptyset$, the following hold: 
  \begin{compactitem}
    \item\label{it1:closure} $\lang{\A_\cap} = \lang{\A_1} \cap \lang{\A_2}$, where
      $\A_\cap = \tuple{\Sigma,X,Q_1 \cup Q_2, \iota_1 \wedge \iota_2,
      F_1 \cup F_2, \Delta_1 \cup \Delta_2}$, 
      %
    \item\label{it2:closure} $\lang{\overline{\A_i}} = \Sigma[X]^* \setminus
      \lang{\A_i}$, where $\overline{\A_i} =
      \tuple{\Sigma,X,Q_i,\dual{\iota},Q_i\setminus
        F_i,\overline{\Delta_i}}$ and, for all
      $i=1,2$: \[q(x_1,\ldots,x_{\#(q)}) \arrow{a(X)}{} \phi \in
      \Delta_i \iff q(x_1,\ldots,x_{\#(q)}) \arrow{a(X)}{} \dual{\phi}
      \in \overline{\Delta_i} \enspace.\]
  \end{compactitem}
  Moreover, $\len{\A_\cap} = \bigO{\len{\A_1}+\len{\A_2}}$ and
  $\len{\overline{\A_i}} = \bigO{\len{\A_i}}$, for all $i=1,2$.
\end{theorem}
\proof{\qed}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\bibliographystyle{abbrv} \bibliography{refs}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{document}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
